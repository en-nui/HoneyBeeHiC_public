# Honey bee HiC python scripts

Author: Chris Robinson
## Bioinformatic pipeline used for data analysis of HiC data. Includes a summary of the pipeline and some of the important Python scripts. Please contact me for any requests or questions regarding how something was done.
## Please refer to manuscript methods section first regarding software used and flags.

#### Preprocessing and assembly
We processed all reads using BBduk (trimming, removing low QS bases, etc). We used default settings. Each assembly had a plethora of read pairs, so we opted for an individual assembly for each using MEGAHIT (--min-contig-len 1000 --k-min 21 --k-max 141 --k-step 12 --merge-level 20,095). No fancy scripts or anything for this because there were so few metagenomes, so I could just hardcode everything.

#### Mapping and binning

We used bowtie2 (--very-sensitive) to map reads to our assemblies. As expected, we lost approximately ~80% of reads to the honey bee genome, but recovered a high amount of microbial reads. The coverage information and contigs were binned using strategies specific to each componenet of the microbiome. **mMAGs** were called by using Maxbin2, MetaBAT2, and HiCBin to generate a bunch of separate bins that were then combined with DASTool. These were all ran with default settings. We defaulted with this strategy because we had so few metagenomic samples. Due to the relatively low complexity of the honey bee microbiome, we wanted to ensure that we recovered as many representative core taxa across our samples. All bins were queried with checkM, and we retained all the low-contamination and relatively complete (>50%). Our goal was to ensure minimize differences between mMAGs that may have some impact on the HiC connectivity with MGEs, which is why we opted for the more complete assemblies. Again, no fancy scripts since we could lazily hardcode everything. mMAGs were ID'd using GTDB-Tk; prediction and annotation were done with Prokka and DRAM (all default settings, though we skipped using the UniRef database for DRAM).

**vMAGs** were called using a pretty standard viromics identification pipeline. We used VIBRANT 1.2.0, used those as input for checkV, and retained all the high-quality viral contigs. Viruses were dereplicated at 95% ANI and 85% breadth (cd-hit-est -i $cat_virus_file -o $cat_virus_file_dereplicated -c 0.95 -n 10 -aS 0.85). vMAGs were annotated with Cenote-Taker2 and DRAM-V. We looked for metabolic genes (AMGs) using results from VIBRANT and DRAM-V (which is a bit redundant I admit). Again, this is pretty standard, and we highly recommend looking at the Anantharaman Lab or Sullivan Lab's recent papers/SOPs for more insight. 

**pMAGs** were a bit trickier since a lot of plasmid genes look like microbial genes. We opted to use MOB-recon, since the documentation was good, and the program seemed to be fairly conservative with regard to plasmid identification. Since the plasmidome haven't been well-characterized in honey bees, and I'm admittedly very new to plasmid biology, I wanted a program that would perhaps underestimate plasmid diversity if it meant higher confidence in identifying plasmid contigs. Plasmid contigs followed the same dereplication strategy as viruses, but annotation used DRAM. Unfortunately, there is no DRAM-P or plasmid equivalent, and so AMG discovery was done via manual inspection of the annotation tables. 

#### HiC reconstruction

I wrote this a good bit in the paper, but again, I highly recommend following the protocol laid out by Hwang et al (doi: 10.1038/s41564-023-01347-5), especially if it's your first time using this data. There were a few things I did differently post-mapping, but the generation of the HiC matricies is made pretty easy by following their work. **I will note that HiCZin, as wonderful of a tool as it is, was fairly difficult for me to get installed and working on my HPC. Keep that in mind.** But yeah, quality trimmed HiC reads were mapped using bwa mem (bwa mem -5SP or bwa mem -SP). The -5SP flag works on reads that didn't have the adapter trimmed (just in case) and the -SP disables the sort of heuristics that typical read mapping programs use with paired reads. Anyway, we mapped these HiC reads to a big contig database containing all of our dereplicated mMAGs, vMAGs, and pMAGs and generated coverage data using bbduk/samtools. You need all of this as input for HiCZin. Note we used the unlabeled version (which is here: https://github.com/dyxstat/Unlabeled_HiCzin). Basically HiCZin will normally require a csv with taxon-identified contigs, but this removes that. I highly recommend reading the HiCZin paper; it's great! HiC noise calculations were calculating using this [script](https://github.com/en-nui/HoneyBeeHiC_public/blob/main/hic_noise_calculations.py). What you get from HiCZin is a sparse matrix. I was _very_ new to this, so I just converted it into a very inefficient four column array composed of ['source','target','num_edges','read_cov']. 

**Even with this normaliziation, HiC data is VERY noisy.** I highly recommend either using a control spike-in with known MGE interactions _or_ at least having a good understanding of what sort of microbial taxa may be transient or unimportant with respect to community composition. Otherwise, one might need to rely on a lot of weird statistical tricks to try and figure out what is an appropriate threshhold for what is a "real" connection versus not. Don't use arbitrary cut offs if you can help it!!!! Please get in contact if you want to talk through this some more or want to think about interpretations.

#### Inference of HGT between mMAGs and MGEs

We looked for highly similar genes between contigs, really. I took all my contigs and blasted it against itself. I kept anything that was >500 bp and was >97% (and later 99%) similar. In honey bees, the majority of core taxa 16S rRNA gene sequences cluster at 97%, so we reasoned that anything more similar than that (discarding other marker genes) may have been a result of recent HGT since we assume that few things are under as strong purifying selection as the genes encoding ribosomal proteins. The bulk of our matches came from plasmid-associated genes. We can't rule out the case of misassembly (some mMAG genes will be assembled onto plasmids and vice versa), but we only considered cases where nearly identical genes were found on plasmids assembled in different metagenomes. In that case, misassembly would have had to happen at least twice. Many of our ID'd genes were found on plasmids in all 3 metagenomes, which suggests that the assemblers liked to put these plasmid genes together. It could be a consequence of a systemic issue with our assembly strategy and definitely should be investigated further (or you could use plasmids assembled from isolates...), but we thought it was fairly convincing evidence of recent HGT (though we have no direct proof). I did the bulk of figure generation in R using library(circlize). There are _so_ many tutorials online about how to make these figures, so just follow any of those, but I think the important part in reproducing our work is correctly creating the table from the pairwise BLAST (blastn -query $db -db $db -evalue 1e-6 -perc_identity 97 -outfmt '10')

#### Calling SNVs and viral popgen

I used the viral contigs and mapping data for input with anvi'o. I can't recommend anvi'o enough (https://github.com/merenlab/anvio). It's very overwhelming at first, but there's so much that you can do with it, and the visualization of what's actually happening is second-to-none. The documentation is immensely rich and informative, and the Meren Lab is just full of very sweet, frighteningly intelligent people (I'm actually here in their lab as a visiting scientist!). Anyway, I followed this guide (https://merenlab.org/2015/07/20/analyzing-variability/) to produce SNV tables for all of my viral ocntigs. SNV and allele frequencies were used as input for the [population genetic scripts](https://github.com/en-nui/HoneyBeeHiC_public/blob/main/popgen_annotations_summary_statistics_program.py). I'm happy to talk through any of these and what they mean if you have any questions. 


#### IDing vMAG species across genomes

Finally, I wanted to understand if viruses were actually co-occurring in different hives. There are a million ways to do this (and a million papers doing different things). Some look for 1x coverage across 50% of the genome. Some look at an average coverage threshhold. I had some problems with these approaches. For example, temperate phages and inactivate prophage genomes can have a lot of very similiar genes. Recruiting reads to both can really bias your cut off for 1x coverage across genome length. Alternatively, you may have one viral gene that's very abundant across different phage species. In this case, you can have a virus that is <1x coverage in some envrionment across 90% of the genome, but if this one abundant gene recruits an inordinate amount of reads, it can drive the average past your 5x cutoff. All of this can be fixed by manual inspection (which should be done always), but sometimes you have too many contigs. 

We took an approach that was inspired by the mosaic nature of viral genomes due to lots of rearrangements, recombination, and gene/gain loss. First, we identified the average genome-wide coverage and breadth. If we used either of the first two threshholds, we would have found that pretty much all of our phages were present in all metagenomes. To cut that number down, I looked for metaviromic islands, or regions that exhibited coverage much lower than the genome-wide average. I did this in 100 bp windows. These can be caused by the absence of a gene, some sort of rearrangement or inversion, or through high genic variability. I then just counted up the number of windows (100 + 100 + 100...) and asked if the sum of these windows was >= than 25% of the total genome length (genome length/4). If it was, I considered it absent from a genome.  I recruited reads and ID'd islands using [this script](https://github.com/en-nui/HoneyBeeHiC_public/blob/main/sliding_window_genome_island_viruses_WIP.py). Low coverage vMAG windows were combined with annotations using this [script](https://github.com/en-nui/HoneyBeeHiC_public/blob/main/updated_island_counts_USEME.py). 
